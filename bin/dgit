#!/usr/bin/env python 
"""
Tool to manage growing number of datasets and versions 
"""

import os, sys, tempfile
import json
import getpass 
import traceback 
import click 
from click.exceptions import UsageError
from distutils.spawn import find_executable
from dgitcore import datasets, plugins 
from dgitcore.plugins import repomanager
from dgitcore import config, helper 

##############################################################
# Generic settings
##############################################################
thisdir=os.path.realpath(os.path.dirname(__file__))
CONTEXT_SETTINGS=dict(allow_extra_args=True,ignore_unknown_options=True)

##############################################################
# Helper functions..
##############################################################

def repo_option(f):
    def callback(ctx, param, value):
        if value is None: 
            value = config.get_default_dataset() 

        (username, dataset) = helper.parse_dataset_name(value)    
        value = datasets.lookup(username=username, dataset=dataset)
        if value is None: 
            print("Dataset is unspecified. Please use dgit default")
            raise UsageError("dataset is unspecified")

        return value
    return click.option('--repo', '-r',
                        default=None,
                        help="Dataset to operate on",
                        callback=callback)(f)

def common_options(f):
    f = repo_option(f)
    return f        

#####################################################################
# Repo specific commands
#####################################################################
@click.group()
def repo_specific():
    pass 

@repo_specific.command('commit', context_settings=CONTEXT_SETTINGS)
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options
def commit(repo, args):
    """
    Commit repo data
    """
    if len(args) == 0: 
        print("Commit with editor support not available right now")
        print("Use -m <message>")
        return 

    datasets.commit(repo, list(args))

@repo_specific.command('log', context_settings=CONTEXT_SETTINGS)
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options
def log(repo, args):
    """
    Gather the log details
    """
    datasets.log(repo, list(args))

@repo_specific.command('push', context_settings=CONTEXT_SETTINGS)
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options
def push(repo, args):
    """
    Gather the log details
    """
    datasets.push(repo, list(args))

@repo_specific.command('rm',context_settings=CONTEXT_SETTINGS)
@click.option('--force', 
              is_flag=True, 
              default=False,
              help="Force rm")
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options
def rm(repo, force, args): 
    """
    Delete files from repo 
    """
    datasets.delete(repo, force, list(args))

@repo_specific.command('sh',context_settings=CONTEXT_SETTINGS)
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options 
def sh(repo, args): 
    """
    Run generic shell commands in repo
    """
    if len(args) == 0: 
        print("Atleast one command should be provided") 
        return 

    datasets.shellcmd(repo, list(args))

@repo_specific.command('post',context_settings=CONTEXT_SETTINGS)
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options 
def post(repo, args): 
    """
    Post metadata (only) to thirdparty server
    """
    datasets.post(repo, list(args))

@repo_specific.command('stash',context_settings=CONTEXT_SETTINGS)
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options 
def stash(repo, args): 
    """
    Trash all the changes in the dataset
    """
    datasets.stash(repo, list(args))

@repo_specific.command('status',context_settings=CONTEXT_SETTINGS)
@click.option('--details', 
              is_flag=True, 
              default=False,
              help="Show repo details")
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options 
def status(repo, details, args): 
    """
    Status of the repo
    """
    datasets.status(repo, details, list(args))

@repo_specific.command('diff',context_settings=CONTEXT_SETTINGS)
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options 
def diff(repo, args): 
    """
    Show the diff between two commits
    """
    datasets.diff(repo, list(args))

@repo_specific.command('drop', context_settings=CONTEXT_SETTINGS)
@common_options 
def drop(repo): 
    """
    Drop dataset
    """
    datasets.drop(repo)

##############################################################
# Repo specific but more complicated commands 
##############################################################

@repo_specific.command('add-files', context_settings=CONTEXT_SETTINGS)
@click.option("--targetdir", '-t', 
              default=".",
              help="Directory in repo")
@click.option("--include", '-i', 
              multiple=True,
              help="File patterns to include")
@click.option("--generator/--no-generator",
              default=False,
              help="Generator script")
@click.option("--script/--no-script",
              default=False,
              help="Mark the script file as executable")
@click.option("--source",
              default=False,
              help="Source of the data")
@click.option("--execute/--no-execute",
              default=False,
              help="Execute the filename specified")
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options
def add(repo, targetdir, args, execute, 
        generator, source, include, script):
    """
    Add files to the repo
    """


    if generator and execute: 
        print("Generator and execute are mutually exclusive") 
        return 
        
    if execute and len(include) == 0: 
        print("Files to be included must be specified")
        return


    args = helper.clean_args(args, execute) 
    if args is None: 
        return 

    # Cleanup includes 
    includes = []
    for i in include:
        includes.extend(i.split(","))

    datasets.add(repo=repo,
                 args=args, 
                 execute=execute, 
                 source=source,
                 script=script,
                 generator=generator, 
                 targetdir=targetdir, 
                 includes=includes)

@repo_specific.command('add-preview',context_settings=CONTEXT_SETTINGS)
@click.option("--size", '-s', 
              default=512, 
              help="Size of snippet to include")
@click.argument('args', nargs=-1, type=click.UNPROCESSED)
@common_options
def preview(repo, size, args):
    """
    Add files preview from files into metadata 
    """

    datasets.add_preview(repo, size, list(args))

@repo_specific.command('validation',context_settings=CONTEXT_SETTINGS)
@click.argument('action',
                type=click.Choice(['add', 'remove', 'list', 'show', 'test', 'evaluate']))
@click.option('--name', '-n',
              help="Name of the ruleset")
@click.option('--validator', '-v',
              help="Name of the validator")
@click.option('--target', '-t',
              help="Specification for the filename as a pattern")
@click.option('--rules', '-r',
              help="File with validation rules")
@common_options
def validation(repo, action, name, target, rules): 
    """
    Add validation rules
    
    Parameters
    ----------
    filename: Filename pattern to which the rule must be applied 
    rules: jsonfile with rules specificied in the LIVR format (`Language Independent Validation Rules <https://github.com/koorchik/LIVR>`_)
    """

    if dataset is None: 
        dataset = config.get_default_dataset() 

    # Extract the correct dataset name
    (username, dataset) = helper.parse_dataset_name(dataset)    
    if dataset is None: 
        return

    checks = {
        "name must be specified": {
            'test': name is not None,
            'action': ['add', 'remove']
        },
        "rules file to be specified": {
            'test': not os.path.exists(rules),
            'action': ['add', 'test']
        }
    }

    invalid = False
    for c in checks: 
        if action in checks[c]['action'] and checks[c]['test']:
            print(c) 
            invalid = True 
    
    if invalid: 
        return 

@repo_specific.command('remote', context_settings=CONTEXT_SETTINGS)
@click.argument("op",
                type=click.Choice(['add', 'rm', 'rename', 'show']))
@click.argument("dataset")
@click.argument("shortname")
@click.argument("url")
@common_options
def remote(repo, op, shortname, url): 
    """
    Manage remote 
    """

    (username, dataset) = helper.parse_dataset_name(dataset)    
    if dataset is None or username is None: 
        print("Could not find the dataset. Please specify exact repo to be stashed")
        return
    
    
    # git remote add pb https://github.com/paulboone/ticgit
    datasets.remote(op, username, dataset, shortname, url) 
    return 


##############################################################
# Repo generic commands commands 
##############################################################

@click.group()
def repo_generic():
    pass 

@repo_generic.command('default')
@click.argument('action',
              type=click.Choice(['clear', 'get', 'set']),
              default="get")
@click.option('--dataset', '-d',
              default=None,
              help='Dataset')
def default(action,dataset):
    """
    Set the default dataset
    """
    if action == 'set': 
        if dataset is not None: 
            config.set_default_dataset(dataset)
        else: 
            print("Dataset must be specified for set")            
    elif action == "clear": 
        config.clear_default_dataset()
    elif action == "get": 
        dataset = config.get_default_dataset()
        print("Default dataset:", dataset)

@repo_generic.command('list')
@click.option('--remote', '-r',
              is_flag=True, 
              default=False,
              help="List remote repos available")
def list_repos(remote): 
    """
    List datasets
    """
    datasets.list_repos(remote)

@repo_generic.command()
@click.argument("url")
def clone(url): 
    """
    Clone a git URL 
    """
    datasets.clone(url) 
    return 


@repo_generic.command('init', context_settings=CONTEXT_SETTINGS)
@click.argument('dataset')
@click.option("--setup",
              type=click.Choice(['git+s3', 'git']),
              default='git+s3',
              help="What is the backend for this repo")
@click.option("--force",
              default=False,
              is_flag=True,
              help="Force overwriting the directory")
def init(dataset, setup, force): 
    """
    Bootstrap a new dataset (a git repo+s3 backup)
    
    Example: 

    # Create a local repo with s3 backend 
    dgit init --setup git+s3 pingali/hello 

    # Create a local repo with no backends 
    dgit init --setup git pingali/hello 
    """

    (username, dataset) = helper.parse_dataset_name(dataset)    
    if dataset is None: 
        return

    # Get the command that must be run 
    datasets.init(username, dataset, setup, force)

##############################################################
# Management commands 
##############################################################
@click.group()
def management():
    pass 

@management.command('config')
@click.argument('action',
                type=click.Choice(['update', 'init', 'show']))
@click.option('-g',
              "--globalvar",
              nargs=2, 
              multiple=1,
              type=click.Tuple([str,str]),
              help="Update profile variables")
def profile(action, globalvar): 
    """
    Create configuration file (~/.dgit.ini) 
    """
    if action in ["update", "init"]:
        config.update(globalvar)
    elif action == "show":
        config.init(globalvar, show=True)


@management.command('plugins')
@click.argument('action',
                type=click.Choice(['list', 'show', 'new']),
                default='show')
@click.option('--what',
                type=click.Choice(['backend', 'instrumentation', 'repomanager']))
@click.option('--name')              
@click.option('--version')              
def plugin_cmd(action, what, name, version): 
    """
    Plugin management
    """
    if action == "show":
        plugins.show(what, name, version, details=True)
    elif action == "list":
        plugins.show(what, name, version, details=False)
    elif action == "new":
        plugins.generate(what, name, version)

cli = click.CommandCollection(sources=[repo_specific, repo_generic, management])

if __name__ == "__main__":
    
    plugins.load() 
    try: 
        config.init()
        cli() 
    except Exception as e: 
        traceback.print_exc() 
    plugins.close() 


